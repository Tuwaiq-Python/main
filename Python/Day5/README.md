
# File_IO, Directory operations, Exceptions, Decorators



## عمليات الملفات 

الملفات عبارة عن اماكن مُسماة على ذاكرة التخزين ، بداخلها يتم حفظ البيانات لإسترجاعها حسب الحاجة .  يتم استخدامها لحفظ البيانات بشكل دائم . 


لغة البايثون تتيح لنا ادوات للتعامل مع الملفات كالكتابة و القراءة .  لتنفيذ عملية على ملف في الباحثون ، نمر بثلاث خطوات :


- فتح الملف
- تنفيذ العملية (قراءة أو كتابة أو انشاء)
- اغلاق الملف 



فتح ملف

لفتح ملف نستخدم الدالة open  . هذه الدالة تأخذ مسار الملف (path) المراد فتحه كمُعطى بالإضافة الى معطيات اختيارية اخرى . ستقوم الدالة بإرجاع كيان ملف  file object.  بحيث بعدها يمكننا استخدامه لتنفيذ العمليات المطلوبة على الملف .


    file = open("test.txt") # open file in current directory
    file = open("Users/user-name/Documents/test.txt") # or provide full path



أنماط فتح الملف 

عند فتح ملف ما ، فهنالك عدة أنماط للفتح من اجل تحديد نوع العملية المراد تنفيذها . 


- r    : نمط القراءة  - النمط الإفتراضي
- w  : نمط القراءة - يتم انشاء الملف في حال عدم وجوده ، او الكتابة عليه ان وجد
- x   : نمط الإنشاء - يستخدم فقط لإنشاء الملف ، يفشل هذا النمط في حال كان الملف موجود مسبقا
- a   : نمط الإضافة - يفتح الملف للإضافة ، يتم انشاء الملف في حال عدم وجوده
- b   : النمط البيناري (الرقمي الثنائي) 
- r+ : يفتح الملف للقراءة و الكتابة ، موقع المؤشر في البداية
- w+: يفتح الملف للكتابة و القراءة ، يتم الكتابة على المحتويات الموجودة مسبقاً
- a+ : يفتح ملف للإضافة و القراءة ، موقع المؤشر بآخر المحتوى



قراءة محتوى الملف

لقراءة محتوى الملف نستخدم الدالة read ، و التي ستقرىء المحتوى كاملا و ترجعه لك كنص . اختياريا يمكننا ان نزودها بمعطى لتحديد القدر المطلوب قراءتها من البايتات .  يجب ان نكون في نمط القراءة لإستخدام هذه الدالة بنجاح.


    file = open("test.txt", "r", encoding="utf-8")
    content = file.read()
    file.close()




كتابة محتوى لملف 

لكتابة محتوى لملف ، نستخدم الدالة write و التي تأخذ نص str كمُعطى (المحتوى المراد كتابته) . يجب أن نكون في نمط الكتابة أو الإضافة لإستخدام هذه الدالة بنجاح . 


    file = open('test.txt', "w", encoding="utf-8")
    file.write("hey how are you ?")
    file.close()




دوال Seek و Tell

يتم استخدام هذه الدوال من اجل معرفة موقع المؤشر بداخل الملف،  أو من اجل التحكم بموقعه . 

لمعرفة موقع المؤشر داخل الملف نستخدم tell


    file.tell()

للتحكم بموقع المؤشر نستخدم seek و نعطيه الموقع الذي نريده فيه 


    file.seek(4)



عمليات اخرى على الملفات 


- readline() :  يقرأ سطر واحد من الملف و يرجعه كنص
- readlines() :  يقرأ الملف كقائمة من السطور و يرجعها  
- writelines(lines):  دالة تستقبل قائمة من النصوص ، و من ثم تكتبها للملف  






## عمليات المجلدات



ما هو المجلد ؟

المجلد عبارة مجموعة من الملفات  و المجلدات الثانوية . نستخدم المجلدات لترتيب الملفات و الأصول داخل المشروع .  من أجل أن ننفذ عملية ، يجب اولا أن نستورد الوحدة os 

معرفة المجلد العملي الحالي 


    import os
    os.getcwd()

تغيير المجلد العملي 


    # give the path to the directory
    os.chdir('anotherDirectory')


لعرض محتويات المجلد 


    # list the content in the current working directory
    os.listdir()
    os.listdir('path/to/directory')

إنشاء مجلد جديد


    os.mkdir("dir_name")

لإعادة تسمية ملف أو مجلد


    os.rename('old_name','new_name')


حذف ملف


    os.remove("file.txt")

حذف مجلد (خال من المحتويات)


    os.rmdir("folder_path")


حذف مجلد اذا كان بداخله محتويات


    # import shutil first
    import shutil
    shutil.rmtree("folder_path")









## الإستثناءات و التعامل مع الأخطاء Exceptions & Error Handling

 
 خلال رحلتك في تطوير مشروعك على البايثون ستواجه بطبيعة الحال بعض الأخطاء و الإستثناءات التي ستوقف برنامجك . تنقسم الاستثناءات في البايثون الى قسمين :


- أخطاء التركيبة اللغوية
- الأخطاء المنطقية (الاستثناءات)



اخطاء التركيبة اللغوية

هذه الأخطاء متعلقة بتركيبة اللغة Syntax ، حيث تحصل عندما لا يتم اتباع قواعد التركيبة الصحيحة . مثل عدم كتابة اسماء الوظائف بشكل صحيح ، نسيان قوس ، و ما شاكل . و تعتبر هذه الاخطاء من السهل العثور عليها و بالعادة سيساعدك المحرر في اكتشافها و اصلاحها حتى .



الأخطاء المنطقية (الاستثناءات) 

هي الأخطاء التي تحصل اثناء عمل البرنامج ، و بالعادة قد لا تكون سهلة الإكتشاف .  مثل فتح ملف غير موجود ، القسمة على صفر ، و ما شاكل . او الحاجات التي تعتمد على الارتباط بمصادر أخرى ، أو استقبال معطيات من المستخدم . 

عندما لا يتم التعامل بشكل صحيح مع هذه الإستثناءات ، سيتم ايقاف عمل برنامجك بشكل فجائي .  لذا يفضل دائما التعامل معها من اجل الحفاظ على سير البرنامج بشكل صحيح و سلس و حفظ سلامة البيانات . 

عند حصول استثناء ، يقوم مترجم البايثون بطباعة معلومات كاملة عن هذ الإستثناء ، سبب حصوله ، نوعه ، الملف الذي حصل فيه ، و غيرها من المعلومات المهمة لتتبع الخطأ . 

مثال :


    Traceback (most recent call last):
      File "/path/to/project/python code along/exceptions.py", line 4, in <module>
        1/0
    ZeroDivisionError: division by zero



التعامل مع الإسثثناءات 

تتيح لنا لغة البايثون التعامل مع الإستثناءات بشكل فعال ، و ذلك من خلال استخدام Try…Except … Finally  .  ففي حال كانت هنالك عملية قد ترفع  استثناء ، نقوم بإحاطتها (تغليفها) في Try…Except 


    #basic catching erros with try , except
    try:
        print(10/number)
    except:
        print("You are dividing by zero")


الأعلى تعلمنا كيف نتعامل مع استثناء بشكل عام . و لكن بإمكاننا ايضا التعامل مع اخطاء محددة ، من اجل ذلك نستخدم التركيبة التالية  .


    try:
        print(10/number)
    except DivisionByZero:
        print("You are dividing by zero")


بالإمكان ايضا التعامل مع عدة انواع من الأخطاء بشكل مستقل ، باستخدام التركيبة التالية.


    try:
        print(divideBy10(number))
    except DivisionByZero:
        print("You are dividing by zero")
    except (ValueError, ValueTooBig) as ve:
        print(f"something went wrong : {ve}")
    except Exception as e:
        print(e.__class__)




استخدام العبارة else في التعامل مع الإستثناءات 

في بعض الأحيان ، قد يحتاج المبرمج ان ينفذ عملية معينة في حال أن العمليات داخل الـ try تم تنفيذها بنجاح من دون أخطاء . في هذه الحالة ، نستخدم else 


    
    try:
        print(divideBy10(number))
    except DivisionByZero:
        print("You are dividing by zero")
    else:
        print("operation is successful")




استخدام العبارة finally  في التعامل مع الإستثناءات 

في بعض الحالات ، قد يحتاج المبرمج أن ينفذ عملية معينة بغض النظر اذا كانت العملية داخل الـ try تم تنفيذها بنجاح أو مع وجود اخطاء . بحيث يتم تنفيذها بغض النظر عن النتيجة في الـ try . تُستخدم عادة لتنظيف الموارد أو اغلاق بعض الإرتباطات . 


    try:
        print(divideBy10(number))
    except DivisionByZero:
        print("You are dividing by zero")
    except (ValueError, ValueTooBig) as ve:
        print(f"something went wrong : {ve}")
    except Exception as e:
        print(e.__class__)
    else:
        print("operation is successful")
    finally:
        print("do some operation/s wether an exception is raised or not")





رفع الإستثناءات Raising Exceptions

كمبرمج و مع تطور برنامج ، قد تريد أيضا ان تجعل بعض الوظائف التي طورتها ترفع إستثناءات في حال تم استخدامها بشكل غير صحيح من مطورين آخري ، أو في حال استقبال معطيات خاطئة ، و غيرها من الحالات . 

في البايثون يمكننا أن نرفع خطأ من خلال الكلمة المفتاحية raise متبوعة بنوع الإستثناء . لاحظ أنه عند رفع استثناء يتم الخروج من الدالة  أو البرنامج ككل عند تلك النقطة .


    raise DivisionByZero("this is  a raised exception")



الإستثناءات المخصصة Custom Exceptions

بإمكانك ايضا كمطور أن تعرف استثناءات مخصصة لإستخدامك او استخدام زملائك في المشروع . و نحقق هذا الأمر من خلال أن نعرف كلاس يرث من نموذج الإستثناءات الرئيسي من بايثون . كالتالي :


    #define a custom exception
    class ValueTooBig(Exception):
        '''An exception raised when the value is more than 100'''
        pass








## التزيين Decorators

الـتزيين عبارة عن دالة تأخذ دالة أخرى كمعطى و تضيف عليها عمليات من دون تغيير الدالة الأولى . فهي تزينها بوظائف جديدة . 


    def document_it(func):
        def wrapper(*args, **kwargs):
            print("this function name is ", func.__name__)
            return func(*args, **kwargs)
        
        return wrapper
    
    #use the decorator
    @document_it
    def some_func():
        print("some operation")
    
    some_func()
